<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
    <script src="src/three.min.js"></script>
    <script src="js/renderers/Projector.js"></script>
    <script src="js/renderers/CanvasRenderer.js"></script>
    <script src="src/math/Vector3.js"></script>
</head>
<body>
    <script>
        var container;
        var camera, scene, renderer;
        var cube, plane;
        var targetRotation = 0;
        var targetRotationOnMouseDown = 0;
        var mouseX = 0;
        var mouseXOnMouseDown = 0;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var objects = [];
        var intersection = new THREE.Vector3();
        var offset;

        var texture_placeholder,
                isUserInteracting = false,
                onMouseDownMouseX = 0, onMouseDownMouseY = 0,
                lon = 90, onMouseDownLon = 0,
                lat = 15, onMouseDownLat = 0,
                phi = 0, theta = 0,
        target = new THREE.Vector3();
        var plane = new THREE.Plane();
        var INTERSECTED;

        init();
        animate();


        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.y = 200;
            camera.position.z = 500;
            scene = new THREE.Scene();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            var PI2 = Math.PI * 2;
            particleMaterial = new THREE.SpriteCanvasMaterial( {
                color: 0x000000,
                program: function ( context ) {
                    context.beginPath();
                    context.arc( 0, 0, 0.5, 0, PI2, true );
                    context.fill();
                }
            } );


            // Cube
            var geometry = new THREE.BoxGeometry( 100, 100, 100 );
            for ( var i = 0; i < geometry.faces.length; i += 2 ) {
                var hex = Math.random() * 0xffffff;
                //var hex = 0x1133ff;
                geometry.faces[ i ].color.setHex( hex );
                geometry.faces[ i + 1 ].color.setHex( hex );
            }
            var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
            cube = new THREE.Mesh( geometry, material );
            cube.position.x = 0;
            cube.position.y = 50;
            cube.position.z = 0;
            scene.add( cube );

            objects.push( cube );
            // Plane
            /*
            var geometry = new THREE.PlaneBufferGeometry( 500, 500 );
            geometry.rotateX( - Math.PI / 2 );
            var material = new THREE.MeshBasicMaterial( { color: 0xe0e0e0, overdraw: 1, opacity: 0.2 } );
            plane = new THREE.Mesh( geometry, material );
            plane.position.x = 0;
            plane.position.y = 0;
            plane.position.z = 0;
            scene.add( plane );*/
            var size = 500, step = 50;
            var geometry = new THREE.Geometry();
            for ( var i = - size; i <= size; i += step ) {
                geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
                geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
                geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
                geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
            }
            var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );
            var line = new THREE.LineSegments( geometry, material );
            scene.add( line );

            renderer = new THREE.CanvasRenderer();
            renderer.setClearColor( 0xf0f0f0 );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            window.addEventListener( 'resize', onWindowResize, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function onDocumentMouseDown( event ) {
            event.preventDefault();
            isUserInteracting = true;
            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;

            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( objects );
            if ( intersects.length > 0 ) {
                console.log(intersects.length);
                //intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
                intersects[ 0 ].object.material.opacity = 0.5;
                if ( INTERSECTED != intersects[ 0 ].object ) {
                    INTERSECTED = intersects[ 0 ].object;
                    //INTERSECTED.material.opacity = 0.5;
                    INTERSECTED.material.color.setHex(0xFF00FF);

                    if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
                        offset.copy( intersection ).sub( INTERSECTED.position );
                    }
                }
            } else {
                 if ( INTERSECTED ) INTERSECTED.material.opacity = 1;
                 INTERSECTED = null;
            }
        }
        function onDocumentMouseMove( event ) {
            if ( INTERSECTED ) {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );
                if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
                    INTERSECTED.position.copy( intersection.sub( offset ) );
                }
            } else {
                if ( isUserInteracting === true ) {
                    lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
                    lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
                }
            }
        }
        function onDocumentMouseUp( event ) {
            isUserInteracting = false;
            if ( INTERSECTED ) INTERSECTED.material.opacity = 1;
            INTERSECTED = null;
        }
        function onDocumentMouseWheel( event ) {
            camera.fov -= event.wheelDeltaY * 0.05;
            camera.updateProjectionMatrix();
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }
        function render() {
            if ( isUserInteracting === false ) {
                lon += 0.1;
            }
            lat = Math.max( - 85, Math.min( 85, lat ) );
            //console.log(lat);
            phi = THREE.Math.degToRad( 90 - lat );
            theta = THREE.Math.degToRad( lon );
            camera.position.x = -500 * Math.sin( phi ) * Math.cos( theta );
            camera.position.y = 500 * Math.cos( phi );
            camera.position.z = 500 * Math.sin( phi ) * Math.sin( theta );

            camera.lookAt( scene.position );
            renderer.render( scene, camera );
        }
    </script>
</body>
</html>